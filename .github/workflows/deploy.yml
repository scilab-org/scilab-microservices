################################################################################
#  CI/CD â€” Deploy changed services to VPS
#
#  Triggers on push to main. Detects which services changed and rebuilds
#  only those Docker images (no cache) on the VPS via SSH.
#
#  Required GitHub Secrets:
#    VPS_HOST          â€” VPS IP or hostname
#    VPS_USER          â€” SSH user (e.g. root)
#    VPS_SSH_KEY       â€” Private SSH key
#    VPS_PORT          â€” SSH port (default: 22)
################################################################################

name: Deploy Services

on:
  push:
    branches: [main]
    paths:
      - "src/**"
      - "deploy/prod/services/**"

  workflow_dispatch:
    inputs:
      deploy_target:
        description: "Which service(s) to deploy"
        required: true
        default: "all"
        type: choice
        options:
          - all
          - api-gateway
          - user-service
          - management-service
          - lab-service
          - nginx

env:
  PROJECT_DIR: /root/hyperdatalab/scilab-microservices
  COMPOSE_DIR: /root/hyperdatalab/scilab-microservices/deploy/prod/services

jobs:
  # ============================================================================
  # Step 1: Detect which services changed
  # ============================================================================
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      api-gateway: ${{ steps.changes.outputs.api-gateway }}
      user-service: ${{ steps.changes.outputs.user-service }}
      management-service: ${{ steps.changes.outputs.management-service }}
      lab-service: ${{ steps.changes.outputs.lab-service }}
      nginx: ${{ steps.changes.outputs.nginx }}
      shared: ${{ steps.changes.outputs.shared }}
      services-to-deploy: ${{ steps.resolve.outputs.services }}
      has-changes: ${{ steps.resolve.outputs.has-changes }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect file changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            api-gateway:
              - 'src/ApiGateway/**'
            user-service:
              - 'src/Services/User/**'
            management-service:
              - 'src/Services/Management/**'
            lab-service:
              - 'src/Services/Lab/**'
            shared:
              - 'src/Shared/**'
              - 'src/Directory.Build.props'
              - 'src/Directory.Packages.props'
            nginx:
              - 'deploy/prod/services/nginx/**'
              - 'deploy/prod/services/docker-compose.yml'

      - name: Resolve services to deploy
        id: resolve
        run: |
          SERVICES=""

          # Manual trigger â€” use selected target
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TARGET="${{ github.event.inputs.deploy_target }}"
            if [ "$TARGET" = "all" ]; then
              SERVICES="api-gateway user-service management-service lab-service nginx"
            else
              SERVICES="$TARGET"
            fi
          else
            # Auto-detect from changed files
            SHARED="${{ steps.changes.outputs.shared }}"

            # If shared code changed, rebuild all application services
            if [ "$SHARED" = "true" ]; then
              SERVICES="api-gateway user-service management-service lab-service"
            else
              [ "${{ steps.changes.outputs.api-gateway }}" = "true" ] && SERVICES="$SERVICES api-gateway"
              [ "${{ steps.changes.outputs.user-service }}" = "true" ] && SERVICES="$SERVICES user-service"
              [ "${{ steps.changes.outputs.management-service }}" = "true" ] && SERVICES="$SERVICES management-service"
              [ "${{ steps.changes.outputs.lab-service }}" = "true" ] && SERVICES="$SERVICES lab-service"
            fi

            # Nginx config changed
            [ "${{ steps.changes.outputs.nginx }}" = "true" ] && SERVICES="$SERVICES nginx"
          fi

          # Trim whitespace
          SERVICES=$(echo "$SERVICES" | xargs)

          if [ -z "$SERVICES" ]; then
            echo "has-changes=false" >> "$GITHUB_OUTPUT"
            echo "services=" >> "$GITHUB_OUTPUT"
            echo "::notice::No service changes detected. Skipping deploy."
          else
            echo "has-changes=true" >> "$GITHUB_OUTPUT"
            echo "services=$SERVICES" >> "$GITHUB_OUTPUT"
            echo "::notice::Will deploy: $SERVICES"
          fi

  # ============================================================================
  # Step 2: Deploy to VPS via SSH
  # ============================================================================
  deploy:
    name: Deploy to VPS
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    environment: production
    concurrency:
      group: deploy-production
      cancel-in-progress: false

    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1
        env:
          SERVICES: ${{ needs.detect-changes.outputs.services-to-deploy }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_PASSWORD }}
          port: ${{ secrets.VPS_PORT || 22 }}
          envs: SERVICES
          command_timeout: 30m
          script: |
            set -euo pipefail

            PROJECT_DIR="/root/hyperdatalab/scilab-microservices"
            COMPOSE_DIR="$PROJECT_DIR/deploy/prod/services"
            echo "Deploying services: $SERVICES"

            # ------------------------------------------------------------------
            # 1. Pull latest code
            # ------------------------------------------------------------------
            cd "$PROJECT_DIR"
            git fetch -q origin main
            git reset --hard origin/main >/dev/null

            # ------------------------------------------------------------------
            # 2. Determine which docker compose services to rebuild
            # ------------------------------------------------------------------
            BUILD_SERVICES=""
            RESTART_ONLY=""

            for SERVICE in $SERVICES; do
              case $SERVICE in
                nginx)
                  # Nginx uses a pre-built image, just restart
                  RESTART_ONLY="$RESTART_ONLY nginx"
                  ;;
                *)
                  BUILD_SERVICES="$BUILD_SERVICES $SERVICE"
                  ;;
              esac
            done

            BUILD_SERVICES=$(echo "$BUILD_SERVICES" | xargs)
            RESTART_ONLY=$(echo "$RESTART_ONLY" | xargs)

            cd "$COMPOSE_DIR"

            # ------------------------------------------------------------------
            # 3. Rebuild changed services (no cache)
            # ------------------------------------------------------------------
            if [ -n "$BUILD_SERVICES" ]; then
              docker compose build --no-cache $BUILD_SERVICES
              docker compose up -d --no-deps $BUILD_SERVICES >/dev/null
            fi

            # ------------------------------------------------------------------
            # 4. Restart nginx if config changed
            # ------------------------------------------------------------------
            if [ -n "$RESTART_ONLY" ]; then
              docker compose up -d --no-deps --force-recreate $RESTART_ONLY >/dev/null
            fi

            # ------------------------------------------------------------------
            # 5. Health check (wait for services to be ready)
            # ------------------------------------------------------------------
            sleep 30

            # Check for unhealthy containers only among deployed services
            UNHEALTHY_SERVICES=""
            for SERVICE in $SERVICES; do
              CID=$(docker compose ps -q "$SERVICE" 2>/dev/null || true)
              if [ -z "$CID" ]; then
                continue
              fi

              HEALTH=$(docker inspect --format '{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' "$CID" 2>/dev/null || echo "unknown")
              if [ "$HEALTH" = "unhealthy" ]; then
                UNHEALTHY_SERVICES="$UNHEALTHY_SERVICES $SERVICE"
              fi
            done

            UNHEALTHY_SERVICES=$(echo "$UNHEALTHY_SERVICES" | xargs || true)
            if [ -n "$UNHEALTHY_SERVICES" ]; then
              UNHEALTHY_COUNT=$(echo "$UNHEALTHY_SERVICES" | wc -w | xargs)
              echo "::error::WARNING: $UNHEALTHY_COUNT unhealthy deployed service(s): $UNHEALTHY_SERVICES"
              for SERVICE in $UNHEALTHY_SERVICES; do
                echo "--- $SERVICE logs ---"
                docker compose logs --tail=30 "$SERVICE"
              done
              exit 1
            fi

            # ------------------------------------------------------------------
            # 6. Cleanup old Docker resources
            # ------------------------------------------------------------------
            docker image prune -f >/dev/null || true
            docker builder prune -f --filter "until=24h" >/dev/null || true
            echo "Deployment completed"

      - name: Deployment summary
        if: always()
        run: |
          echo "### Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch** | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Services** | \`${{ needs.detect-changes.outputs.services-to-deploy }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Triggered by** | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ${{ job.status }} |" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Step 3: Notify on failure
  # ============================================================================
  notify-failure:
    name: Notify on Failure
    needs: [detect-changes, deploy]
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Create failure issue
        uses: actions/github-script@v7
        with:
          script: |
            const services = '${{ needs.detect-changes.outputs.services-to-deploy }}';
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš¨ Deployment failed â€” ${new Date().toISOString().split('T')[0]}`,
              body: [
                `## Deployment Failure`,
                ``,
                `| Property | Value |`,
                `|----------|-------|`,
                `| **Commit** | ${context.sha} |`,
                `| **Branch** | ${context.ref} |`,
                `| **Services** | ${services} |`,
                `| **Run** | [#${context.runNumber}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) |`,
                `| **Actor** | @${context.actor} |`,
                ``,
                `Please check the [workflow logs](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}).`,
              ].join('\n'),
              labels: ['deployment', 'bug'],
            });
